require Geometry;


object GeometryLocationAttribute : BaseAttribute {
  /// Values array container
  GeometryLocation values[];
};

/// \internal
function Size GeometryLocationAttribute.size() {
  return this.values.size();
}
/// \internal
inline GeometryLocationAttribute.resize!(Size count) {
  this.parent.resize(count);
  this.values.resize(count);
}
/// \internal
inline Data GeometryLocationAttribute.data() {
  return this.values.data();
}
/// \internal
inline Boolean GeometryLocationAttribute.equalValues( Size index1, Size index2 ) {
  if (
    this.values[index1].index == this.values[index2].index &&
    this.values[index1].subIndex == this.values[index2].subIndex &&
    this.values[index1].barycentric == this.values[index2].barycentric
  ) {
    return true;
  } else {
    return false;
  }
}
/// \internal
inline GeometryLocationAttribute.copyValue!( Size sourceIndex, Size targetIndex ) {
  this.values[targetIndex] = this.values[sourceIndex];
}
/// \internal
inline GeometryLocationAttribute.copyValue!( Ref<Object> sourceAttr, Size sourceIndex, Size targetIndex ) {
  Ref<GeometryLocationAttribute> source = sourceAttr;
  this.values[targetIndex] = source.values[sourceIndex];
}
/// \internal
inline GeometryLocationAttribute.copyFrom!( Ref<Object> otherAttr ) {
  this.parent.copyFrom( otherAttr );
  Ref<GeometryLocationAttribute> other = otherAttr;

  // Copy in place to avoid mallocs
  Size size = other.values.size();
  for( Size i = 0; i < size; ++i )
    this.values[i] = other.values[i];
}

/** Returns a linear combination of source values.
    \param sourceIndices The array of source indices
    \param sourceWeights The array of source weights, which need to correspond to each sourceIndices. Normally the sum of the weights should be 1.0
*/
/// \internal
inline GeometryLocation GeometryLocationAttribute.getLinearCombination( LocalL16UInt32Array sourceIndices, LocalL16ScalarArray sourceWeights ) {
  // Unable to support this usefully
  // Copying from highest weight value instead.
  Scalar weight = 0.0f;
  UInt32 copyIndex = 0;
  for (Size i = 0; i < sourceWeights.count; i++) {
    if (sourceWeights.get(i) > weight) {
      weight = sourceWeights.get(i);
      copyIndex = sourceIndices.get(i);
    }
  }
  return this.values[copyIndex];
}
/// \internal
inline GeometryLocationAttribute.linearCombine!( Ref<Object> sourceAttr, LocalL16UInt32Array sourceIndices, LocalL16ScalarArray sourceWeights, Size targetIndex ) {
  //just copies the highest weight value
  Ref<GeometryLocationAttribute> source = sourceAttr;
  this.values[targetIndex] = source.getLinearCombination( sourceIndices, sourceWeights );
}
/// \internal
inline Size GeometryLocationAttribute.getScalarValueSize() {
  // unsupported
  // Is not expressible as a list of scalars.
  return 0;
}
/// \internal
inline GeometryLocationAttribute.setFromScalar!( Size index, LocalL16ScalarArray value ) {
  // unsupported
  // Is not expressible as a list of scalars.
}
/// \internal
function String GeometryLocationAttribute.valueDesc( Size index ) {
  return String(this.values[index]);
}
require Util;
/// \internal
function String GeometryLocationAttribute.unitTestPrint( Size index ) {
  return
    "Index: " + String(this.values[index].index) +
    "Subindex: " + String(this.values[index].subIndex) +
    unitTestPrint( this.values[index].barycentric
  );
}


/// \internal
function StatisticRecord[] GeometryLocationAttribute.getStatistics() {
  StatisticRecord stats[] = this.parent.getStatistics();
  stats.push( StatisticRecord( Statistic_MemoryUsage, this.values.size()*4*3 + this.values.size()*4*2) ); // I think?
  return stats;
}

// function GeometryLocationAttribute GeometryLocationAttribute.clone() {
//   //The difference with default clone() is that new.parent.autoStat will point to 'new' (from constructor)
//   GeometryLocationAttribute new = GeometryLocationAttribute();
//   new.parent.cloneFrom(this);//Copies all but the values
//   new.values = this.values.clone();
//   return new;
// }

/// If it exists, returns the attribute of that name, else creates it.
/// \internal
function Ref<GeometryLocationAttribute> GeometryAttributes.getOrCreateGeometryLocationAttribute!( String name ) {
  Ref<GeometryAttribute> attr = this.getAttribute( name, GeometryLocationAttribute );
  if( attr )
    return attr;

  GeometryLocationAttribute newAttr = GeometryLocationAttribute();
  newAttr._attachToContainer( name, this );
  return newAttr;
}
