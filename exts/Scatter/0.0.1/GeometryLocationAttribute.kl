

require Geometry;
object GeometryLocationAttribute : BaseAttribute {
  /// Values array container
  GeometryLocation values[];
};


function Size GeometryLocationAttribute.size() {
  return this.values.size();
}

inline GeometryLocationAttribute.resize!(Size count) {
  this.parent.resize(count);
  this.values.resize(count);
}

inline Data GeometryLocationAttribute.data() {
  return this.values.data();
}

inline Boolean GeometryLocationAttribute.equalValues( Size index1, Size index2 ) {
  if (
    this.values[index1].index == this.values[index2].index &&
    this.values[index1].subIndex == this.values[index2].subIndex &&
    this.values[index1].barycentric == this.values[index2].barycentric
  ) {
    return true;
  } else {
    return false;
  }
}

inline GeometryLocationAttribute.copyValue!( Size sourceIndex, Size targetIndex ) {
  this.values[targetIndex] = this.values[sourceIndex];
}

inline GeometryLocationAttribute.copyValue!( Ref<Object> sourceAttr, Size sourceIndex, Size targetIndex ) { 
  Ref<GeometryLocationAttribute> source = sourceAttr;
  this.values[targetIndex] = source.values[sourceIndex];
}

inline GeometryLocationAttribute.copyFrom!( Ref<Object> otherAttr ) {
  this.parent.copyFrom( otherAttr );
  Ref<GeometryLocationAttribute> other = otherAttr;

  // Copy in place to avoid mallocs
  Size size = other.values.size();
  for( Size i = 0; i < size; ++i )
    this.values[i] = other.values[i];
}

/** Returns a linear combination of source values.
    \param sourceIndices The array of source indices
    \param sourceWeights The array of source weights, which need to correspond to each sourceIndices. Normally the sum of the weights should be 1.0
*/
inline GeometryLocation GeometryLocationAttribute.getLinearCombination( LocalL16UInt32Array sourceIndices, LocalL16ScalarArray sourceWeights ) {
  // Unable to support this usefully
  // Copying from highest weight value instead. 
  Scalar weight = 0.0f;
  UInt32 copyIndex = 0;
  for (Size i = 0; i < sourceWeights.count; i++) {
    if (sourceWeights.get(i) > weight) {
      weight = sourceWeights.get(i);
      copyIndex = sourceIndices.get(i);
    }
  }
  return this.values[copyIndex];
}

inline GeometryLocationAttribute.linearCombine!( Ref<Object> sourceAttr, LocalL16UInt32Array sourceIndices, LocalL16ScalarArray sourceWeights, Size targetIndex ) {
  //just copies the highest weight value
  Ref<GeometryLocationAttribute> source = sourceAttr;
  this.values[targetIndex] = source.getLinearCombination( sourceIndices, sourceWeights );
}

inline Size GeometryLocationAttribute.getScalarValueSize() {
  // unsupported
  // Is not expressible as a list of scalars.
  return 0;
}

inline GeometryLocationAttribute.setFromScalar!( Size index, LocalL16ScalarArray value ) {
  // unsupported
  // Is not expressible as a list of scalars.
}

function String GeometryLocationAttribute.valueDesc( Size index ) {
  return String(this.values[index]);
}

require Util;
function String GeometryLocationAttribute.unitTestPrint( Size index ) {
  return 
    "Index: " + String(this.values[index].index) + 
    "Subindex: " + String(this.values[index].subIndex) + 
    unitTestPrint( this.values[index].barycentric
  );
}



function StatisticRecord[] GeometryLocationAttribute.getStatistics() {
  StatisticRecord stats[] = this.parent.getStatistics();
  stats.push( StatisticRecord( Statistic_MemoryUsage, this.values.size()*4*3 + this.values.size()*4*2) ); // I think? 
  return stats;
}

// function GeometryLocationAttribute GeometryLocationAttribute.clone() {
//   //The difference with default clone() is that new.parent.autoStat will point to 'new' (from constructor)
//   GeometryLocationAttribute new = GeometryLocationAttribute();
//   new.parent.cloneFrom(this);//Copies all but the values
//   new.values = this.values.clone();
//   return new;
// }


/// If it exists, returns the attribute of that name, else creates it.
function Ref<GeometryLocationAttribute> GeometryAttributes.getOrCreateGeometryLocationAttribute!( String name ) {
  Ref<GeometryAttribute> attr = this.getAttribute( name, GeometryLocationAttribute );
  if( attr )
    return attr;

  GeometryLocationAttribute newAttr = GeometryLocationAttribute();
  newAttr._attachToContainer( name, this );
  return newAttr;
}
